package com.pushtorefresh.storio.sample.db.entities;

import android.support.annotation.NonNull;
import android.support.annotation.Nullable;
import android.util.Log;

import com.pushtorefresh.storio.sample.R;
import com.pushtorefresh.storio.sample.db.tables.AntsTable;
import com.pushtorefresh.storio.sample.db.tables.QueensTable;
import com.pushtorefresh.storio.sqlite.annotations.StorIOSQLiteColumn;
import com.pushtorefresh.storio.sqlite.annotations.StorIOSQLiteType;
import com.pushtorefresh.storio.sqlite.operations.put.PutResults;
import com.pushtorefresh.storio.sqlite.queries.Query;
import com.pushtorefresh.storio.sqlite.StorIOSQLite;

import java.util.ArrayList;
import java.util.List;

import javax.inject.Inject;

import rx.Observer;
import rx.Subscription;
import rx.android.schedulers.AndroidSchedulers;
import rx.functions.Action1;
import timber.log.Timber;

import static com.pushtorefresh.storio.sample.ui.Toasts.safeShowShortToast;
import static rx.android.schedulers.AndroidSchedulers.mainThread;

@StorIOSQLiteType(table = QueensTable.TABLE)
public class Queen {

    /**
     * If object was not inserted into db, id will be null
     */
    @Nullable
    @StorIOSQLiteColumn(name = QueensTable.COLUMN_ID, key = true)
    Long id;

    @NonNull
    @StorIOSQLiteColumn(name = QueensTable.COLUMN_NICK)
    String name;

    @NonNull
    List<Ant> ants = new ArrayList<Ant>();

    // In this sample app we use dependency injection (DI) to keep the code clean
    // Just remember that it's already configured instance of StorIOSQLite from DbModule
//    @Inject
//    StorIOSQLite storIOSQLite;

/////////////////////////////////////////////////////////////////////////////////

    // leave default constructor for AutoGenerated code!
    Queen() {}

    private Queen(@Nullable Long id, @NonNull String name) {
        this.id     = id;
        this.name   = name;
    }

    @NonNull
    public static Queen newQueen(@Nullable Long id, @NonNull String name) {
        return new Queen(id, name);
    }

    @NonNull
    public static Queen newQueen(@NonNull String name) {
        return new Queen(null, name);
    }

    public static void saveQueen(StorIOSQLite storIOSQLite, List<Queen> queens) {
        storIOSQLite
                .put()
                .objects(queens)
                .prepare()
                .createObservable()
                .observeOn(mainThread()) // Remember, all Observables in StorIO already subscribed on Schedulers.io(), you just need to set observeOn()
                .subscribe(new Observer<PutResults<Queen>>() {
                    @Override
                    public void onError(Throwable e) {
                        Log.d("Queen", "#000");
//                        safeShowShortToast(getActivity(), R.string.queen_ants_add_error_toast);
                    }

                    @Override
                    public void onNext(PutResults<Queen> putResults) {
                        // After successful Put Operation our subscriber in reloadData() will receive update!
                        Log.d("Queen", "queen.id is still null -> here it's not possible to save ants");
                    }

                    @Override
                    public void onCompleted() {
                        // no impl required
                        Log.d("Queen", "#002");
                    }
                });
    }

    @Nullable
    public Long getId() {
        return id;
    }

    public void setId(@Nullable Long id) {
        this.id = id;
    }

    @NonNull
    public String getName() {
        return name;
    }

    public void setName(@NonNull String name) {
        this.name = name;
    }

    @NonNull
    public List<Ant> getAnts(StorIOSQLite storIOSQLite) {
        if ( storIOSQLite != null && ants.size() == 0 ) {
            final Subscription subscription = storIOSQLite
                    .get()
                    .listOfObjects(Ant.class)
                    .withQuery(Query.builder()
                            .table(AntsTable.TABLE)
                            .build())
                    .prepare()
                    .createObservable() // Get Result as rx.Observable and subscribe to further updates of tables from Query!
                    .take(1)  // To get result only once and ignore further changes of this table
                    .observeOn(AndroidSchedulers.mainThread()) // All Rx operations work on Schedulers.io()
//                    .subscribe(new Action1<List<Ant>>() {
//                        @Override
//                        public void call(List<Ant> ants) {
//                            // Remember: subscriber will automatically receive updates
//                            // Of tables from Query (tweets table in our case)
//                            // This makes your code really Reactive and nice!
//
//                            // We guarantee, that list of objects will never be null (also we use @NonNull/@Nullable)
//                            // So you just need to check if it's empty or not
//                            return ants;
//                        }
//                    }, new Action1<Throwable>() {
//                        @Override
//                        public void call(Throwable throwable) {
//                            // In cases when you are not sure that query will be successful
//                            // You can prevent crash of the application via error handler
//                            Timber.e(throwable, "reloadData()");
//                        }
//                    });
                    .subscribe(ants -> { // Please don't forget to unsubscribe
                        // will be called with first result and then after each change of tables from Query
                        // several changes in transaction -> one notification
                        this.ants = ants;
                    }
            );
            subscription.unsubscribe();
        }

        return ants;
    }

    public void setAnts(@NonNull List<Ant> ants) {
        this.ants = ants;
    }
}
